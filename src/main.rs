#![allow(unused_imports)]
#![allow(dead_code)]
#![feature(nll)]

use std::fs::File;
use std::io::Read;
use std::io::Write;

mod records;
mod yarp_data;
mod yarp_meta;

use crate::records::*;
use crate::yarp_data::YarpData;
use crate::yarp_meta::*;
use serde_json;
use serde_yaml;
use std::env;
use liquid::ParserBuilder;

fn process_csv(path: &str) {
    let file_in = File::open(path).expect("Unable to open file to read.");
    let file_out = File::create("AutoGenerated.wurst").expect("Unable to open file to write.");
    let mut file_from_csv = File::create("from_csv.yaml").expect("Unable to open file to write.");
    let mut file_from_internal = File::create("from_internal.yaml").expect("Unable to open file to write.");

    let mut reader = csv::ReaderBuilder::new()
        .flexible(true)
        .has_headers(false)
        .from_reader(file_in);

    // let mut generator = CodeGenerator::new(file_out);
    let mut consumer_context = RecordConsumerContext::default();
    let mut id_registry = IdRegistry::default();
    let mut unit_registry = UnitRegistry::default();
    let mut model_registry = ModelRegistry::default();

    for (count, record) in reader.records().enumerate() {
        if let Ok(record) = record {
            print!("{}: Found record. ", count);
            let parsed_record = Record::from_record(&record);

            if let Some(parsed_record) = parsed_record {
                print!("Parsed. {:?}", parsed_record);
                consume_record(
                    parsed_record,
                    &mut consumer_context,
                    &mut id_registry,
                    &mut unit_registry,
                    &mut model_registry,
                );
            } else {
                print!("Couldn't parse. {:?}", record);
            }
        } else {
            print!("{}: No record found.", count);
        }

        println!();
    }

    let yaml_output = serde_yaml::to_string(&YarpData::from_meta(
        // &consumer_context,
        &id_registry,
        &unit_registry,
        &model_registry,
    ))
    .unwrap();

    write!(file_from_csv, ">>>>>>>>>>>>>> generated from csv\n{}", yaml_output);

    let yarp_data: YarpData = serde_yaml::from_str(&yaml_output).unwrap();

    let new_meta = transform_yarp_data(&yarp_data);

    let reserialized = serde_yaml::to_string(&YarpData::from_meta(
        &new_meta.id,
        &new_meta.unit,
        &new_meta.model
    )).unwrap();

    write!(file_from_internal, ">>>>>>>>>>>>>> regenerated from model\n{}", reserialized);

    let context = liquid_context(&new_meta).into_object().unwrap();

    let template = ParserBuilder::with_liquid().build().unwrap().parse(include_str!("codegen_template.liquid")).unwrap();
    println!("{}", template.render(&context).unwrap());

    // generator.emit();
}

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{}", &args[1]);
    process_csv(&args[1]);
}
