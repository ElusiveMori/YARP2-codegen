#![allow(unused_imports)]
#![allow(dead_code)]
#![feature(nll)]

use std::fs::File;
use std::io::Read;
use std::io::Write;

mod records;
mod yarp_data;
mod yarp_meta;

use crate::records::*;
use crate::yarp_data::YarpData;
use crate::yarp_meta::*;
use serde_json;
use serde_yaml;
use std::env;

fn process_csv(path: &str) {
    let file_in = File::open(path).expect("Unable to open file to read.");
    let file_out = File::create("AutoGenerated.wurst").expect("Unable to open file to write.");

    let mut reader = csv::ReaderBuilder::new()
        .flexible(true)
        .has_headers(false)
        .from_reader(file_in);

    // let mut generator = CodeGenerator::new(file_out);
    let mut consumer_context = RecordConsumerContext::default();
    let mut id_registry = IdRegistry::default();
    let mut unit_registry = UnitRegistry::default();

    for (count, record) in reader.records().enumerate() {
        if let Ok(record) = record {
            print!("{}: Found record. ", count);
            let parsed_record = Record::from_record(&record);

            if let Some(parsed_record) = parsed_record {
                print!("Parsed. {:?}", parsed_record);
                consume_record(
                    parsed_record,
                    &mut consumer_context,
                    &mut id_registry,
                    &mut unit_registry,
                );
            } else {
                print!("Couldn't parse. {:?}", record);
            }
        } else {
            print!("{}: No record found.", count);
        }

        println!();
    }

    println!(
        "\n\n{}\n\n",
        serde_yaml::to_string(&YarpData::from_meta(
            &consumer_context,
            &id_registry,
            &unit_registry
        ))
        .unwrap()
    );

    // generator.emit();
}

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{}", &args[1]);
    process_csv(&args[1]);
}
